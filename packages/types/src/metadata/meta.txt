{
  magicNumber: 1,635,018,093,
  metadata: {
    V11: {
      modules: [
        {
          name: System,
          storage: {
            prefix: System,
            items: [
              {
                name: Account,
                modifier: Default,
                type: {
                  Map: {
                    hasher: Blake2_128Concat,
                    key: AccountId,
                    value: AccountInfo,
                    linked: false
                  }
                },
                fallback: 0x000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000,
                documentation: [
                   The full account information for a particular account ID.
                ]
              },
              {
                name: ExtrinsicCount,
                modifier: Optional,
                type: {
                  Plain: u32
                },
                fallback: 0x00,
                documentation: [
                   Total extrinsics count for the current block.
                ]
              },
              {
                name: BlockWeight,
                modifier: Default,
                type: {
                  Plain: ExtrinsicsWeight
                },
                fallback: 0x00000000000000000000000000000000,
                documentation: [
                   The current weight for the block.
                ]
              },
              {
                name: AllExtrinsicsLen,
                modifier: Optional,
                type: {
                  Plain: u32
                },
                fallback: 0x00,
                documentation: [
                   Total length (in bytes) for all extrinsics put together, for the current block.
                ]
              },
              {
                name: BlockHash,
                modifier: Default,
                type: {
                  Map: {
                    hasher: Twox64Concat,
                    key: BlockNumber,
                    value: Hash,
                    linked: false
                  }
                },
                fallback: 0x0000000000000000000000000000000000000000000000000000000000000000,
                documentation: [
                   Map of block numbers to block hashes.
                ]
              },
              {
                name: ExtrinsicData,
                modifier: Default,
                type: {
                  Map: {
                    hasher: Twox64Concat,
                    key: u32,
                    value: Bytes,
                    linked: false
                  }
                },
                fallback: 0x00,
                documentation: [
                   Extrinsics data for the current block (maps an extrinsic's index to its data).
                ]
              },
              {
                name: Number,
                modifier: Default,
                type: {
                  Plain: BlockNumber
                },
                fallback: 0x00000000,
                documentation: [
                   The current block number being processed. Set by `execute_block`.
                ]
              },
              {
                name: ParentHash,
                modifier: Default,
                type: {
                  Plain: Hash
                },
                fallback: 0x0000000000000000000000000000000000000000000000000000000000000000,
                documentation: [
                   Hash of the previous block.
                ]
              },
              {
                name: ExtrinsicsRoot,
                modifier: Default,
                type: {
                  Plain: Hash
                },
                fallback: 0x0000000000000000000000000000000000000000000000000000000000000000,
                documentation: [
                   Extrinsics root of the current block, also part of the block header.
                ]
              },
              {
                name: Digest,
                modifier: Default,
                type: {
                  Plain: DigestOf
                },
                fallback: 0x00,
                documentation: [
                   Digest of the current block, also part of the block header.
                ]
              },
              {
                name: Events,
                modifier: Default,
                type: {
                  Plain: Vec<EventRecord>
                },
                fallback: 0x00,
                documentation: [
                   Events deposited for the current block.
                ]
              },
              {
                name: EventCount,
                modifier: Default,
                type: {
                  Plain: EventIndex
                },
                fallback: 0x00000000,
                documentation: [
                   The number of events in the `Events<T>` list.
                ]
              },
              {
                name: EventTopics,
                modifier: Default,
                type: {
                  Map: {
                    hasher: Blake2_128Concat,
                    key: Hash,
                    value: Vec<(BlockNumber,EventIndex)>,
                    linked: false
                  }
                },
                fallback: 0x00,
                documentation: [
                   Mapping between a topic (represented by T::Hash) and a vector of indexes,
                   of events in the `<Events<T>>` list.,
                  ,
                   All topic vectors have deterministic storage locations depending on the topic. This,
                   allows light-clients to leverage the changes trie storage tracking mechanism and,
                   in case of changes fetch the list of events of interest.,
                  ,
                   The value has the type `(T::BlockNumber, EventIndex)` because if we used only just,
                   the `EventIndex` then in case if the topic has the same contents on the next block,
                   no notification will be triggered thus the event might be lost.
                ]
              },
              {
                name: LastRuntimeUpgrade,
                modifier: Optional,
                type: {
                  Plain: LastRuntimeUpgradeInfo
                },
                fallback: 0x00,
                documentation: [
                   Stores the `spec_version` and `spec_name` of when the last runtime upgrade happened.
                ]
              },
              {
                name: ExecutionPhase,
                modifier: Optional,
                type: {
                  Plain: Phase
                },
                fallback: 0x00,
                documentation: [
                   The execution phase of the block.
                ]
              }
            ]
          },
          calls: [
            {
              name: fill_block,
              args: [
                {
                  name: _ratio,
                  type: Perbill
                }
              ],
              documentation: [
                 A dispatch that will fill the block weight up to the given ratio.
              ]
            },
            {
              name: remark,
              args: [
                {
                  name: _remark,
                  type: Bytes
                }
              ],
              documentation: [
                 Make some on-chain remark.,
                ,
                 # <weight>,
                 - `O(1)`,
                 - Base Weight: 0.665 µs, independent of remark length.,
                 - No DB operations.,
                 # </weight>
              ]
            },
            {
              name: set_heap_pages,
              args: [
                {
                  name: pages,
                  type: u64
                }
              ],
              documentation: [
                 Set the number of pages in the WebAssembly environment's heap.,
                ,
                 # <weight>,
                 - `O(1)`,
                 - 1 storage write.,
                 - Base Weight: 1.405 µs,
                 - 1 write to HEAP_PAGES,
                 # </weight>
              ]
            },
            {
              name: set_code,
              args: [
                {
                  name: code,
                  type: Bytes
                }
              ],
              documentation: [
                 Set the new runtime code.,
                ,
                 # <weight>,
                 - `O(C + S)` where `C` length of `code` and `S` complexity of `can_set_code`,
                 - 1 storage write (codec `O(C)`).,
                 - 1 call to `can_set_code`: `O(S)` (calls `sp_io::misc::runtime_version` which is expensive).,
                 - 1 event.,
                 The weight of this function is dependent on the runtime, but generally this is very expensive.,
                 We will treat this as a full block.,
                 # </weight>
              ]
            },
            {
              name: set_code_without_checks,
              args: [
                {
                  name: code,
                  type: Bytes
                }
              ],
              documentation: [
                 Set the new runtime code without doing any checks of the given `code`.,
                ,
                 # <weight>,
                 - `O(C)` where `C` length of `code`,
                 - 1 storage write (codec `O(C)`).,
                 - 1 event.,
                 The weight of this function is dependent on the runtime. We will treat this as a full block.,
                 # </weight>
              ]
            },
            {
              name: set_changes_trie_config,
              args: [
                {
                  name: changes_trie_config,
                  type: Option<ChangesTrieConfiguration>
                }
              ],
              documentation: [
                 Set the new changes trie configuration.,
                ,
                 # <weight>,
                 - `O(1)`,
                 - 1 storage write or delete (codec `O(1)`).,
                 - 1 call to `deposit_log`: Uses `append` API, so O(1),
                 - Base Weight: 7.218 µs,
                 - DB Weight:,
                     - Writes: Changes Trie, System Digest,
                 # </weight>
              ]
            },
            {
              name: set_storage,
              args: [
                {
                  name: items,
                  type: Vec<KeyValue>
                }
              ],
              documentation: [
                 Set some items of storage.,
                ,
                 # <weight>,
                 - `O(I)` where `I` length of `items`,
                 - `I` storage writes (`O(1)`).,
                 - Base Weight: 0.568 * i µs,
                 - Writes: Number of items,
                 # </weight>
              ]
            },
            {
              name: kill_storage,
              args: [
                {
                  name: keys,
                  type: Vec<Key>
                }
              ],
              documentation: [
                 Kill some items from storage.,
                ,
                 # <weight>,
                 - `O(IK)` where `I` length of `keys` and `K` length of one key,
                 - `I` storage deletions.,
                 - Base Weight: .378 * i µs,
                 - Writes: Number of items,
                 # </weight>
              ]
            },
            {
              name: kill_prefix,
              args: [
                {
                  name: prefix,
                  type: Key
                },
                {
                  name: _subkeys,
                  type: u32
                }
              ],
              documentation: [
                 Kill all storage items with a key that starts with the given prefix.,
                ,
                 **NOTE:** We rely on the Root origin to provide us the number of subkeys under,
                 the prefix we are removing to accurately calculate the weight of this function.,
                ,
                 # <weight>,
                 - `O(P)` where `P` amount of keys with prefix `prefix`,
                 - `P` storage deletions.,
                 - Base Weight: 0.834 * P µs,
                 - Writes: Number of subkeys + 1,
                 # </weight>
              ]
            },
            {
              name: suicide,
              args: [],
              documentation: [
                 Kill the sending account, assuming there are no references outstanding and the composite,
                 data is equal to its default value.,
                ,
                 # <weight>,
                 - `O(1)`,
                 - 1 storage read and deletion.,
                 --------------------,
                 Base Weight: 8.626 µs,
                 No DB Read or Write operations because caller is already in overlay,
                 # </weight>
              ]
            }
          ],
          events: [
            {
              name: ExtrinsicSuccess,
              args: [
                DispatchInfo
              ],
              documentation: [
                 An extrinsic completed successfully. [info]
              ]
            },
            {
              name: ExtrinsicFailed,
              args: [
                DispatchError,
                DispatchInfo
              ],
              documentation: [
                 An extrinsic failed. [error, info]
              ]
            },
            {
              name: CodeUpdated,
              args: [],
              documentation: [
                 `:code` was updated.
              ]
            },
            {
              name: NewAccount,
              args: [
                AccountId
              ],
              documentation: [
                 A new [account] was created.
              ]
            },
            {
              name: KilledAccount,
              args: [
                AccountId
              ],
              documentation: [
                 An [account] was reaped.
              ]
            }
          ],
          constants: [
            {
              name: BlockHashCount,
              type: BlockNumber,
              value: 0xfa000000,
              documentation: [
                 The maximum number of blocks to allow in mortal eras.
              ]
            },
            {
              name: MaximumBlockWeight,
              type: Weight,
              value: 0x00204aa9d1010000,
              documentation: [
                 The maximum weight of a block.
              ]
            },
            {
              name: DbWeight,
              type: RuntimeDbWeight,
              value: 0x40787d010000000000e1f50500000000,
              documentation: [
                 The weight of runtime database operations the runtime can invoke.
              ]
            },
            {
              name: BlockExecutionWeight,
              type: Weight,
              value: 0x0000000000000000,
              documentation: [
                 The base weight of executing a block, independent of the transactions in the block.
              ]
            },
            {
              name: ExtrinsicBaseWeight,
              type: Weight,
              value: 0x4059730700000000,
              documentation: [
                 The base weight of an Extrinsic in the block, independent of the of extrinsic being executed.
              ]
            },
            {
              name: MaximumBlockLength,
              type: u32,
              value: 0x00005000,
              documentation: [
                 The maximum length of a block (in bytes).
              ]
            }
          ],
          errors: [
            {
              name: InvalidSpecName,
              documentation: [
                 The name of specification does not match between the current runtime,
                 and the new runtime.
              ]
            },
            {
              name: SpecVersionNeedsToIncrease,
              documentation: [
                 The specification version is not allowed to decrease between the current runtime,
                 and the new runtime.
              ]
            },
            {
              name: FailedToExtractRuntimeVersion,
              documentation: [
                 Failed to extract the runtime version from the new runtime.,
                ,
                 Either calling `Core_version` or decoding `RuntimeVersion` failed.
              ]
            },
            {
              name: NonDefaultComposite,
              documentation: [
                 Suicide called when the account has non-default composite data.
              ]
            },
            {
              name: NonZeroRefCount,
              documentation: [
                 There is a non-zero reference count preventing the account from being purged.
              ]
            }
          ]
        },
        {
          name: Timestamp,
          storage: {
            prefix: Timestamp,
            items: [
              {
                name: Now,
                modifier: Default,
                type: {
                  Plain: Moment
                },
                fallback: 0x0000000000000000,
                documentation: [
                   Current time for the current block.
                ]
              },
              {
                name: DidUpdate,
                modifier: Default,
                type: {
                  Plain: bool
                },
                fallback: 0x00,
                documentation: [
                   Did the timestamp get updated in this block?
                ]
              }
            ]
          },
          calls: [
            {
              name: set,
              args: [
                {
                  name: now,
                  type: Compact<Moment>
                }
              ],
              documentation: [
                 Set the current time.,
                ,
                 This call should be invoked exactly once per block. It will panic at the finalization,
                 phase, if this call hasn't been invoked by that time.,
                ,
                 The timestamp should be greater than the previous one by the amount specified by,
                 `MinimumPeriod`.,
                ,
                 The dispatch origin for this call must be `Inherent`.,
                ,
                 # <weight>,
                 - `O(T)` where `T` complexity of `on_timestamp_set`,
                 - 1 storage read and 1 storage mutation (codec `O(1)`). (because of `DidUpdate::take` in `on_finalize`),
                 - 1 event handler `on_timestamp_set` `O(T)`.,
                 - Benchmark: 7.678 (min squares analysis),
                   - NOTE: This benchmark was done for a runtime with insignificant `on_timestamp_set` handlers.,
                     New benchmarking is needed when adding new handlers.,
                 # </weight>
              ]
            }
          ],
          events: null,
          constants: [
            {
              name: MinimumPeriod,
              type: Moment,
              value: 0xb80b000000000000,
              documentation: [
                 The minimum period between blocks. Beware that this is different to the *expected* period,
                 that the block production apparatus provides. Your chosen consensus system will generally,
                 work with this to determine a sensible block time. e.g. For Aura, it will be double this,
                 period on default settings.
              ]
            }
          ],
          errors: []
        },
        {
          name: Balances,
          storage: {
            prefix: Balances,
            items: [
              {
                name: TotalIssuance,
                modifier: Default,
                type: {
                  Plain: Balance
                },
                fallback: 0x00000000000000000000000000000000,
                documentation: [
                   The total units issued in the system.
                ]
              },
              {
                name: Account,
                modifier: Default,
                type: {
                  Map: {
                    hasher: Blake2_128Concat,
                    key: AccountId,
                    value: AccountData,
                    linked: false
                  }
                },
                fallback: 0x00000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000,
                documentation: [
                   The balance of an account.,
                  ,
                   NOTE: This is only used in the case that this module is used to store balances.
                ]
              },
              {
                name: Locks,
                modifier: Default,
                type: {
                  Map: {
                    hasher: Blake2_128Concat,
                    key: AccountId,
                    value: Vec<BalanceLock>,
                    linked: false
                  }
                },
                fallback: 0x00,
                documentation: [
                   Any liquidity locks on some account balances.,
                   NOTE: Should only be accessed when setting, changing and freeing a lock.
                ]
              },
              {
                name: StorageVersion,
                modifier: Default,
                type: {
                  Plain: Releases
                },
                fallback: 0x00,
                documentation: [
                   Storage version of the pallet.,
                  ,
                   This is set to v2.0.0 for new networks.
                ]
              }
            ]
          },
          calls: [
            {
              name: transfer,
              args: [
                {
                  name: dest,
                  type: LookupSource
                },
                {
                  name: value,
                  type: Compact<Balance>
                }
              ],
              documentation: [
                 Transfer some liquid free balance to another account.,
                ,
                 `transfer` will set the `FreeBalance` of the sender and receiver.,
                 It will decrease the total issuance of the system by the `TransferFee`.,
                 If the sender's account is below the existential deposit as a result,
                 of the transfer, the account will be reaped.,
                ,
                 The dispatch origin for this call must be `Signed` by the transactor.,
                ,
                 # <weight>,
                 - Dependent on arguments but not critical, given proper implementations for,
                   input config types. See related functions below.,
                 - It contains a limited number of reads and writes internally and no complex computation.,
                ,
                 Related functions:,
                ,
                   - `ensure_can_withdraw` is always called internally but has a bounded complexity.,
                   - Transferring balances to accounts that did not exist before will cause,
                      `T::OnNewAccount::on_new_account` to be called.,
                   - Removing enough funds from an account will trigger `T::DustRemoval::on_unbalanced`.,
                   - `transfer_keep_alive` works the same way as `transfer`, but has an additional,
                     check that the transfer will not kill the origin account.,
                 ---------------------------------,
                 - Base Weight: 73.64 µs, worst case scenario (account created, account removed),
                 - DB Weight: 1 Read and 1 Write to destination account,
                 - Origin account is already in memory, so no DB operations for them.,
                 # </weight>
              ]
            },
            {
              name: set_balance,
              args: [
                {
                  name: who,
                  type: LookupSource
                },
                {
                  name: new_free,
                  type: Compact<Balance>
                },
                {
                  name: new_reserved,
                  type: Compact<Balance>
                }
              ],
              documentation: [
                 Set the balances of a given account.,
                ,
                 This will alter `FreeBalance` and `ReservedBalance` in storage. it will,
                 also decrease the total issuance of the system (`TotalIssuance`).,
                 If the new free or reserved balance is below the existential deposit,,
                 it will reset the account nonce (`frame_system::AccountNonce`).,
                ,
                 The dispatch origin for this call is `root`.,
                ,
                 # <weight>,
                 - Independent of the arguments.,
                 - Contains a limited number of reads and writes.,
                 ---------------------,
                 - Base Weight:,
                     - Creating: 27.56 µs,
                     - Killing: 35.11 µs,
                 - DB Weight: 1 Read, 1 Write to `who`,
                 # </weight>
              ]
            },
            {
              name: force_transfer,
              args: [
                {
                  name: source,
                  type: LookupSource
                },
                {
                  name: dest,
                  type: LookupSource
                },
                {
                  name: value,
                  type: Compact<Balance>
                }
              ],
              documentation: [
                 Exactly as `transfer`, except the origin must be root and the source account may be,
                 specified.,
                 # <weight>,
                 - Same as transfer, but additional read and write because the source account is,
                   not assumed to be in the overlay.,
                 # </weight>
              ]
            },
            {
              name: transfer_keep_alive,
              args: [
                {
                  name: dest,
                  type: LookupSource
                },
                {
                  name: value,
                  type: Compact<Balance>
                }
              ],
              documentation: [
                 Same as the [`transfer`] call, but with a check that the transfer will not kill the,
                 origin account.,
                ,
                 99% of the time you want [`transfer`] instead.,
                ,
                 [`transfer`]: struct.Module.html#method.transfer,
                 # <weight>,
                 - Cheaper than transfer because account cannot be killed.,
                 - Base Weight: 51.4 µs,
                 - DB Weight: 1 Read and 1 Write to dest (sender is in overlay already),
                 #</weight>
              ]
            }
          ],
          events: [
            {
              name: Endowed,
              args: [
                AccountId,
                Balance
              ],
              documentation: [
                 An account was created with some free balance. [account, free_balance]
              ]
            },
            {
              name: DustLost,
              args: [
                AccountId,
                Balance
              ],
              documentation: [
                 An account was removed whose balance was non-zero but below ExistentialDeposit,,
                 resulting in an outright loss. [account, balance]
              ]
            },
            {
              name: Transfer,
              args: [
                AccountId,
                AccountId,
                Balance
              ],
              documentation: [
                 Transfer succeeded. [from, to, value]
              ]
            },
            {
              name: BalanceSet,
              args: [
                AccountId,
                Balance,
                Balance
              ],
              documentation: [
                 A balance was set by root. [who, free, reserved]
              ]
            },
            {
              name: Deposit,
              args: [
                AccountId,
                Balance
              ],
              documentation: [
                 Some amount was deposited (e.g. for transaction fees). [who, deposit]
              ]
            },
            {
              name: Reserved,
              args: [
                AccountId,
                Balance
              ],
              documentation: [
                 Some balance was reserved (moved from free to reserved). [who, value]
              ]
            },
            {
              name: Unreserved,
              args: [
                AccountId,
                Balance
              ],
              documentation: [
                 Some balance was unreserved (moved from reserved to free). [who, value]
              ]
            },
            {
              name: ReserveRepatriated,
              args: [
                AccountId,
                AccountId,
                Balance,
                Status
              ],
              documentation: [
                 Some balance was moved from the reserve of the first account to the second account.,
                 Final argument indicates the destination balance type.,
                 [from, to, balance, destination_status]
              ]
            }
          ],
          constants: [
            {
              name: ExistentialDeposit,
              type: Balance,
              value: 0x00000000000000000000000000000000,
              documentation: [
                 The minimum amount required to keep an account open.
              ]
            }
          ],
          errors: [
            {
              name: VestingBalance,
              documentation: [
                 Vesting balance too high to send value
              ]
            },
            {
              name: LiquidityRestrictions,
              documentation: [
                 Account liquidity restrictions prevent withdrawal
              ]
            },
            {
              name: Overflow,
              documentation: [
                 Got an overflow after adding
              ]
            },
            {
              name: InsufficientBalance,
              documentation: [
                 Balance too low to send value
              ]
            },
            {
              name: ExistentialDeposit,
              documentation: [
                 Value too low to create account due to existential deposit
              ]
            },
            {
              name: KeepAlive,
              documentation: [
                 Transfer/payment would kill account
              ]
            },
            {
              name: ExistingVestingSchedule,
              documentation: [
                 A vesting schedule already exists for this account
              ]
            },
            {
              name: DeadAccount,
              documentation: [
                 Beneficiary account must pre-exist
              ]
            }
          ]
        },
        {
          name: Sudo,
          storage: {
            prefix: Sudo,
            items: [
              {
                name: Key,
                modifier: Default,
                type: {
                  Plain: AccountId
                },
                fallback: 0x0000000000000000000000000000000000000000000000000000000000000000,
                documentation: [
                   The `AccountId` of the sudo key.
                ]
              }
            ]
          },
          calls: [
            {
              name: sudo,
              args: [
                {
                  name: call,
                  type: Call
                }
              ],
              documentation: [
                 Authenticates the sudo key and dispatches a function call with `Root` origin.,
                ,
                 The dispatch origin for this call must be _Signed_.,
                ,
                 # <weight>,
                 - O(1).,
                 - Limited storage reads.,
                 - One DB write (event).,
                 - Weight of derivative `call` execution + 10,000.,
                 # </weight>
              ]
            },
            {
              name: sudo_unchecked_weight,
              args: [
                {
                  name: call,
                  type: Call
                },
                {
                  name: _weight,
                  type: Weight
                }
              ],
              documentation: [
                 Authenticates the sudo key and dispatches a function call with `Root` origin.,
                 This function does not check the weight of the call, and instead allows the,
                 Sudo user to specify the weight of the call.,
                ,
                 The dispatch origin for this call must be _Signed_.,
                ,
                 # <weight>,
                 - O(1).,
                 - The weight of this call is defined by the caller.,
                 # </weight>
              ]
            },
            {
              name: set_key,
              args: [
                {
                  name: new,
                  type: LookupSource
                }
              ],
              documentation: [
                 Authenticates the current sudo key and sets the given AccountId (`new`) as the new sudo key.,
                ,
                 The dispatch origin for this call must be _Signed_.,
                ,
                 # <weight>,
                 - O(1).,
                 - Limited storage reads.,
                 - One DB change.,
                 # </weight>
              ]
            },
            {
              name: sudo_as,
              args: [
                {
                  name: who,
                  type: LookupSource
                },
                {
                  name: call,
                  type: Call
                }
              ],
              documentation: [
                 Authenticates the sudo key and dispatches a function call with `Signed` origin from,
                 a given account.,
                ,
                 The dispatch origin for this call must be _Signed_.,
                ,
                 # <weight>,
                 - O(1).,
                 - Limited storage reads.,
                 - One DB write (event).,
                 - Weight of derivative `call` execution + 10,000.,
                 # </weight>
              ]
            }
          ],
          events: [
            {
              name: Sudid,
              args: [
                DispatchResult
              ],
              documentation: [
                 A sudo just took place. [result]
              ]
            },
            {
              name: KeyChanged,
              args: [
                AccountId
              ],
              documentation: [
                 The [sudoer] just switched identity; the old key is supplied.
              ]
            },
            {
              name: SudoAsDone,
              args: [
                bool
              ],
              documentation: [
                 A sudo just took place. [result]
              ]
            }
          ],
          constants: [],
          errors: [
            {
              name: RequireSudo,
              documentation: [
                 Sender must be the Sudo account
              ]
            }
          ]
        },
        {
          name: RandomnessCollectiveFlip,
          storage: {
            prefix: RandomnessCollectiveFlip,
            items: [
              {
                name: RandomMaterial,
                modifier: Default,
                type: {
                  Plain: Vec<Hash>
                },
                fallback: 0x00,
                documentation: [
                   Series of block headers from the last 81 blocks that acts as random seed material. This,
                   is arranged as a ring buffer with `block_number % 81` being the index into the `Vec` of,
                   the oldest hash.
                ]
              }
            ]
          },
          calls: [],
          events: null,
          constants: [],
          errors: []
        },
        {
          name: ParachainUpgrade,
          storage: {
            prefix: ParachainUpgrade,
            items: [
              {
                name: PendingValidationFunction,
                modifier: Optional,
                type: {
                  Plain: (RelayChainBlockNumber,ValidationFunction)
                },
                fallback: 0x00,
                documentation: []
              },
              {
                name: DidUpdateVFPs,
                modifier: Default,
                type: {
                  Plain: bool
                },
                fallback: 0x00,
                documentation: [
                   Were the VFPs updated this block?
                ]
              }
            ]
          },
          calls: [
            {
              name: schedule_upgrade,
              args: [
                {
                  name: validation_function,
                  type: ValidationFunction
                }
              ],
              documentation: []
            },
            {
              name: set_validation_function_parameters,
              args: [
                {
                  name: vfp,
                  type: ValidationFunctionParams
                }
              ],
              documentation: [
                 Set the current validation function parameters,
                ,
                 This should be invoked exactly once per block. It will panic at the finalization,
                 phease if the call was not invoked.,
                ,
                 The dispatch origin for this call must be `Inherent`,
                ,
                 As a side effect, this function upgrades the current validation function,
                 if the appropriate time has come.
              ]
            }
          ],
          events: [
            {
              name: ValidationFunctionStored,
              args: [
                RelayChainBlockNumber
              ],
              documentation: []
            },
            {
              name: ValidationFunctionApplied,
              args: [
                RelayChainBlockNumber
              ],
              documentation: []
            }
          ],
          constants: [],
          errors: []
        },
        {
          name: MessageBroker,
          storage: null,
          calls: [
            {
              name: execute_downward_messages,
              args: [
                {
                  name: messages,
                  type: Vec<DownwardMessage>
                }
              ],
              documentation: [
                 Executes the given downward messages by calling the message handlers.,
                ,
                 The origin of this call needs to be `None` as this is an inherent.
              ]
            }
          ],
          events: [
            {
              name: UpwardMessageSent,
              args: [
                Hash
              ],
              documentation: [
                 An upward message was sent to the relay chain.,
                ,
                 The hash corresponds to the hash of the encoded upward message.
              ]
            }
          ],
          constants: [],
          errors: []
        },
        {
          name: TransactionPayment,
          storage: {
            prefix: TransactionPayment,
            items: [
              {
                name: NextFeeMultiplier,
                modifier: Default,
                type: {
                  Plain: Multiplier
                },
                fallback: 0x000064a7b3b6e00d0000000000000000,
                documentation: []
              },
              {
                name: StorageVersion,
                modifier: Default,
                type: {
                  Plain: Releases
                },
                fallback: 0x00,
                documentation: []
              }
            ]
          },
          calls: null,
          events: null,
          constants: [
            {
              name: TransactionByteFee,
              type: BalanceOf,
              value: 0x000064a7b3b6e00d0000000000000000,
              documentation: [
                 The fee to be paid for making a transaction; the per-byte portion.
              ]
            },
            {
              name: WeightToFee,
              type: Vec<WeightToFeeCoefficient>,
              value: 0x04000064a7b3b6e00d0000000000000000000000000001,
              documentation: [
                 The polynomial that is applied in order to derive fee from weight.
              ]
            }
          ],
          errors: []
        },
        {
          name: ParachainInfo,
          storage: {
            prefix: ParachainUpgrade,
            items: [
              {
                name: ParachainId,
                modifier: Default,
                type: {
                  Plain: ParaId
                },
                fallback: 0xc8000000,
                documentation: []
              }
            ]
          },
          calls: null,
          events: null,
          constants: [],
          errors: []
        },
        {
          name: Permissions,
          storage: {
            prefix: PermissionsStoreModule,
            items: [
              {
                name: Permissions,
                modifier: Optional,
                type: {
                  DoubleMap: {
                    hasher: Blake2_256,
                    key1: u32,
                    key2: AccountId,
                    value: Permission,
                    key2Hasher: Blake2_256
                  }
                },
                fallback: 0x00,
                documentation: [
                   Storage with double keys (permission_id, holder_id).
                ]
              }
            ]
          },
          calls: [],
          events: [
            {
              name: PermissionGranted,
              args: [
                u32,
                AccountId
              ],
              documentation: [
                 Permission was granted to a holder. [permission, who]
              ]
            },
            {
              name: PermissionTransfered,
              args: [
                u32,
                AccountId
              ],
              documentation: [
                 Permission was transfered to a new owner. [permission, who]
              ]
            },
            {
              name: PermissionCreated,
              args: [
                u32,
                AccountId
              ],
              documentation: [
                 Permission was created with an owner. [permission, who]
              ]
            }
          ],
          constants: [],
          errors: [
            {
              name: PermissionNotFound,
              documentation: [
                 Account doesn't hold a permission.
              ]
            },
            {
              name: PermissionNotOwned,
              documentation: [
                 Account doesn't own a permission.
              ]
            },
            {
              name: PermissionAlreadyExists,
              documentation: [
                 Permission already exists in the system.
              ]
            }
          ]
        },
        {
          name: TokenDealer,
          storage: null,
          calls: [
            {
              name: transfer_tokens_to_relay_chain,
              args: [
                {
                  name: dest,
                  type: AccountId
                },
                {
                  name: amount,
                  type: BalanceOf
                }
              ],
              documentation: [
                 Transfer `amount` of tokens on the relay chain from the Parachain account to,
                 the given `dest` account.
              ]
            },
            {
              name: transfer_tokens_to_parachain_chain,
              args: [
                {
                  name: para_id,
                  type: u32
                },
                {
                  name: dest,
                  type: AccountId
                },
                {
                  name: amount,
                  type: BalanceOf
                }
              ],
              documentation: [
                 Transfer `amount` of tokens to another parachain.
              ]
            }
          ],
          events: [
            {
              name: TransferredTokensToRelayChain,
              args: [
                AccountId,
                Balance
              ],
              documentation: [
                 Transferred tokens to the account on the relay chain.
              ]
            },
            {
              name: TransferredTokensFromRelayChain,
              args: [
                AccountId,
                Balance
              ],
              documentation: [
                 Transferred tokens to the account on request from the relay chain.
              ]
            },
            {
              name: TransferredTokensViaXCMP,
              args: [
                ParaId,
                AccountId,
                Balance,
                DispatchResult
              ],
              documentation: [
                 Transferred tokens to the account from the given parachain account.
              ]
            }
          ],
          constants: [],
          errors: []
        },
        {
          name: TemplateModule,
          storage: {
            prefix: TemplateModule,
            items: [
              {
                name: Something,
                modifier: Optional,
                type: {
                  Plain: u32
                },
                fallback: 0x00,
                documentation: []
              }
            ]
          },
          calls: [
            {
              name: do_something,
              args: [
                {
                  name: something,
                  type: u32
                }
              ],
              documentation: [
                 An example dispatchable that takes a singles value as a parameter, writes the value to,
                 storage and emits an event. This function must be dispatched by a signed extrinsic.
              ]
            },
            {
              name: cause_error,
              args: [],
              documentation: [
                 An example dispatchable that may throw a custom error.
              ]
            }
          ],
          events: [
            {
              name: SomethingStored,
              args: [
                u32,
                AccountId
              ],
              documentation: [
                 Event documentation should end with an array that provides descriptive names for event,
                 parameters. [something, who]
              ]
            }
          ],
          constants: [],
          errors: [
            {
              name: NoneValue,
              documentation: [
                 Error names should be descriptive.
              ]
            },
            {
              name: StorageOverflow,
              documentation: [
                 Errors should have helpful documentation associated with them.
              ]
            }
          ]
        },
        {
          name: ReferralSystem,
          storage: {
            prefix: ReferralSystem,
            items: [
              {
                name: ReferrerAccount,
                modifier: Default,
                type: {
                  Map: {
                    hasher: Blake2_128Concat,
                    key: AccountId,
                    value: AccountId,
                    linked: false
                  }
                },
                fallback: 0x0000000000000000000000000000000000000000000000000000000000000000,
                documentation: []
              }
            ]
          },
          calls: [],
          events: [],
          constants: [],
          errors: []
        },
        {
          name: XorFee,
          storage: {
            prefix: XorFee,
            items: []
          },
          calls: [],
          events: [],
          constants: [],
          errors: []
        },
        {
          name: Tokens,
          storage: {
            prefix: Tokens,
            items: [
              {
                name: TotalIssuance,
                modifier: Default,
                type: {
                  Map: {
                    hasher: Twox64Concat,
                    key: CurrencyId,
                    value: Balance,
                    linked: false
                  }
                },
                fallback: 0x00000000000000000000000000000000,
                documentation: [
                   The total issuance of a token type.
                ]
              },
              {
                name: Locks,
                modifier: Default,
                type: {
                  DoubleMap: {
                    hasher: Blake2_128Concat,
                    key1: AccountId,
                    key2: CurrencyId,
                    value: Vec<BalanceLock>,
                    key2Hasher: Twox64Concat
                  }
                },
                fallback: 0x00,
                documentation: [
                   Any liquidity locks of a token type under an account.,
                   NOTE: Should only be accessed when setting, changing and freeing a lock.
                ]
              },
              {
                name: Accounts,
                modifier: Default,
                type: {
                  DoubleMap: {
                    hasher: Blake2_128Concat,
                    key1: AccountId,
                    key2: CurrencyId,
                    value: AccountData,
                    key2Hasher: Twox64Concat
                  }
                },
                fallback: 0x000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000,
                documentation: [
                   The balance of a token type under an account.,
                  ,
                   NOTE: If the total is ever zero, decrease account ref account.,
                  ,
                   NOTE: This is only used in the case that this module is used to store balances.
                ]
              }
            ]
          },
          calls: null,
          events: [
            {
              name: Transferred,
              args: [
                CurrencyId,
                AccountId,
                AccountId,
                Balance
              ],
              documentation: [
                 Token transfer success. [currency_id, from, to, amount]
              ]
            }
          ],
          constants: [],
          errors: [
            {
              name: BalanceTooLow,
              documentation: [
                 The balance is too low
              ]
            },
            {
              name: TotalIssuanceOverflow,
              documentation: [
                 This operation will cause total issuance to overflow
              ]
            },
            {
              name: AmountIntoBalanceFailed,
              documentation: [
                 Cannot convert Amount into Balance type
              ]
            },
            {
              name: LiquidityRestrictions,
              documentation: [
                 Failed because liquidity restrictions due to locking
              ]
            }
          ]
        },
        {
          name: Currencies,
          storage: null,
          calls: [
            {
              name: transfer,
              args: [
                {
                  name: dest,
                  type: LookupSource
                },
                {
                  name: currency_id,
                  type: CurrencyIdOf
                },
                {
                  name: amount,
                  type: Compact<BalanceOf>
                }
              ],
              documentation: [
                 Transfer some balance to another account under `currency_id`.,
                ,
                 The dispatch origin for this call must be `Signed` by the transactor.,
                ,
                 # <weight>,
                 - Preconditions:,
                 t- T::MultiCurrency is orml_tokens,
                tt- T::NativeCurrency is pallet_balances,
                 - Complexity: `O(1)`,
                 - Db reads: 5,
                 - Db writes: 2,
                 -------------------,
                 Base Weight:,
                tt- non-native currency: 90.23 µs,
                tt- native currency in worst case: 70 µs,
                 # </weight>
              ]
            },
            {
              name: transfer_native_currency,
              args: [
                {
                  name: dest,
                  type: LookupSource
                },
                {
                  name: amount,
                  type: Compact<BalanceOf>
                }
              ],
              documentation: [
                 Transfer some native currency to another account.,
                ,
                 The dispatch origin for this call must be `Signed` by the transactor.,
                ,
                 # <weight>,
                 - Preconditions:,
                 t- T::MultiCurrency is orml_tokens,
                tt- T::NativeCurrency is pallet_balances,
                 - Complexity: `O(1)`,
                 - Db reads: 2 * `Accounts`,
                 - Db writes: 2 * `Accounts`,
                 -------------------,
                 Base Weight: 70 µs,
                 # </weight>
              ]
            },
            {
              name: update_balance,
              args: [
                {
                  name: who,
                  type: LookupSource
                },
                {
                  name: currency_id,
                  type: CurrencyIdOf
                },
                {
                  name: amount,
                  type: AmountOf
                }
              ],
              documentation: [
                 update amount of account `who` under `currency_id`.,
                ,
                 The dispatch origin of this call must be _Root_.,
                ,
                 # <weight>,
                 - Preconditions:,
                 t- T::MultiCurrency is orml_tokens,
                tt- T::NativeCurrency is pallet_balances,
                 - Complexity: `O(1)`,
                 - Db reads:,
                 t- non-native currency: 5,
                 - Db writes:,
                 t- non-native currency: 2,
                 -------------------,
                 Base Weight:,
                 t- non-native currency: 66.24 µs,
                tt- native currency and killing account: 26.33 µs,
                tt- native currency and create account: 27.39 µs,
                 # </weight>
              ]
            }
          ],
          events: [
            {
              name: Transferred,
              args: [
                CurrencyId,
                AccountId,
                AccountId,
                Balance
              ],
              documentation: [
                 Currency transfer success. [currency_id, from, to, amount]
              ]
            },
            {
              name: BalanceUpdated,
              args: [
                CurrencyId,
                AccountId,
                Amount
              ],
              documentation: [
                 Update balance success. [currency_id, who, amount]
              ]
            },
            {
              name: Deposited,
              args: [
                CurrencyId,
                AccountId,
                Balance
              ],
              documentation: [
                 Deposit success. [currency_id, who, amount]
              ]
            },
            {
              name: Withdrawn,
              args: [
                CurrencyId,
                AccountId,
                Balance
              ],
              documentation: [
                 Withdraw success. [currency_id, who, amount]
              ]
            }
          ],
          constants: [
            {
              name: NativeCurrencyId,
              type: CurrencyIdOf,
              value: 0x00,
              documentation: []
            }
          ],
          errors: [
            {
              name: AmountIntoBalanceFailed,
              documentation: [
                 Unable to convert the Amount type into Balance.
              ]
            },
            {
              name: BalanceTooLow,
              documentation: [
                 Balance is too low.
              ]
            }
          ]
        },
        {
          name: TradingPair,
          storage: null,
          calls: [
            {
              name: register,
              args: [
                {
                  name: dex_id,
                  type: DEXId
                },
                {
                  name: base_asset_id,
                  type: AssetId
                },
                {
                  name: target_asset_id,
                  type: AssetId
                }
              ],
              documentation: [
                 Register trading pair on the given DEX.,
                 Can be only called by the DEX owner.,
                ,
                 - `dex_id`: ID of the exchange.,
                 - `base_asset_id`: base asset ID.,
                 - `target_asset_id`: target asset ID.,
                ,
                 TODO: add information about weight
              ]
            }
          ],
          events: [
            {
              name: TradingPairStored,
              args: [
                DEXId,
                TP
              ],
              documentation: []
            }
          ],
          constants: [],
          errors: [
            {
              name: TradingPairExists,
              documentation: [
                 Registering trading pair already exists.
              ]
            },
            {
              name: ForbiddenBaseAssetId,
              documentation: [
                 The specified base asset ID for the trading pair is not allowed.
              ]
            },
            {
              name: IdenticalAssetIds,
              documentation: [
                 The specified base asset ID is the same as target asset ID.
              ]
            },
            {
              name: TradingPairDoesntExist,
              documentation: [
                 Trading pair is not registered for given DEXId.
              ]
            }
          ]
        },
        {
          name: Assets,
          storage: null,
          calls: [
            {
              name: register,
              args: [
                {
                  name: asset_id,
                  type: AssetId
                }
              ],
              documentation: [
                 Performs an asset registration.,
                ,
                 Basically, this function checks the if given `asset_id` has an owner,
                 and if not, inserts it.
              ]
            }
          ],
          events: [
            {
              name: AssetRegistered,
              args: [
                AssetId,
                AccountId
              ],
              documentation: []
            }
          ],
          constants: [],
          errors: [
            {
              name: AssetIdAlreadyExists,
              documentation: [
                 An asset with a given ID already exists.
              ]
            },
            {
              name: AssetIdNotExists,
              documentation: [
                 An asset with a given ID not exists.
              ]
            },
            {
              name: Permissions,
              documentation: [
                 Permissions error
              ]
            },
            {
              name: InsufficientBalance,
              documentation: [
                 A number is out of range of the balance type.
              ]
            }
          ]
        },
        {
          name: DEXManager,
          storage: {
            prefix: DEXManager,
            items: [
              {
                name: DEXInfos,
                modifier: Default,
                type: {
                  Map: {
                    hasher: Twox64Concat,
                    key: DEXId,
                    value: DEXInfo,
                    linked: false
                  }
                },
                fallback: 0x0000000000,
                documentation: []
              }
            ]
          },
          calls: [
            {
              name: initialize_dex,
              args: [
                {
                  name: dex_id,
                  type: DEXId
                },
                {
                  name: base_asset_id,
                  type: AssetId
                },
                {
                  name: owner_account_id,
                  type: AccountId
                },
                {
                  name: fee,
                  type: Option<u16>
                },
                {
                  name: protocol_fee,
                  type: Option<u16>
                }
              ],
              documentation: [
                 Initialize DEX in network with given Id, Base Asset, if fees are not given then defaults are applied.,
                ,
                 - `dex_id`: ID of the exchange.,
                 - `fee`: value of fee on swaps in basis points.,
                 - `protocol_fee`: value of fee fraction for protocol beneficiary in basis points.,
                ,
                 TODO: add information about weight
              ]
            },
            {
              name: set_fee,
              args: [
                {
                  name: dex_id,
                  type: DEXId
                },
                {
                  name: fee,
                  type: BasisPoints
                }
              ],
              documentation: [
                 Set fee deduced from tokens during swaps.,
                ,
                 - `dex_id`: ID of the exchange.,
                 - `fee`: value of fee on swaps in basis points.,
                ,
                 TODO: add information about weight
              ]
            },
            {
              name: set_protocol_fee,
              args: [
                {
                  name: dex_id,
                  type: DEXId
                },
                {
                  name: protocol_fee,
                  type: BasisPoints
                }
              ],
              documentation: [
                 Set fee deduced from swaps fee for protocol beneficiary.,
                ,
                 - `dex_id`: ID of the exchange.,
                 - `protocol_fee`: value of fee fraction for protocol beneficiary in basis points.,
                ,
                 TODO: add information about weight
              ]
            }
          ],
          events: [
            {
              name: DEXInitialized,
              args: [
                DEXId
              ],
              documentation: []
            },
            {
              name: FeeChanged,
              args: [
                DEXId,
                u16
              ],
              documentation: []
            },
            {
              name: ProtocolFeeChanged,
              args: [
                DEXId,
                u16
              ],
              documentation: []
            }
          ],
          constants: [],
          errors: [
            {
              name: DEXIdAlreadyExists,
              documentation: [
                 DEX with given id is already registered.
              ]
            },
            {
              name: DEXDoesNotExist,
              documentation: [
                 DEX with given Id is not registered.
              ]
            },
            {
              name: InvalidFeeValue,
              documentation: [
                 Numeric value provided as fee is not valid, e.g. out of basis-point range.
              ]
            },
            {
              name: InvalidAccountId,
              documentation: [
                 Account with given Id is not registered.
              ]
            }
          ]
        },
        {
          name: BondingCurvePool,
          storage: null,
          calls: null,
          events: null,
          constants: [],
          errors: [
            {
              name: CalculatePriceFailed,
              documentation: [
                 An error occurred while calculating the price.
              ]
            },
            {
              name: CantExchangeOnItself,
              documentation: [
                 The pool can't perform exchange on itself.
              ]
            },
            {
              name: NotEnoughReserves,
              documentation: [
                 It's not enough reserves in the pool to perform the operation.
              ]
            }
          ]
        },
        {
          name: Technical,
          storage: null,
          calls: [
            {
              name: create_swap,
              args: [
                {
                  name: action,
                  type: SwapAction
                }
              ],
              documentation: []
            }
          ],
          events: [
            {
              name: Minted,
              args: [
                TechAssetId,
                TechAccountId,
                Balance,
                Balance
              ],
              documentation: [
                 Some pure technical assets were minted. [asset, owner, minted_amount, total_exist].,
                 This is not only for pure TechAccountId.,
                 TechAccountId can be just wrapped AccountId.
              ]
            },
            {
              name: Burned,
              args: [
                TechAssetId,
                TechAccountId,
                Balance,
                Balance
              ],
              documentation: [
                 Some pure technical assets were burned. [asset, owner, burned_amount, total_exist].,
                 For full kind of accounts like in Minted.
              ]
            },
            {
              name: OutputTransferred,
              args: [
                TechAssetId,
                TechAccountId,
                AccountId,
                Balance
              ],
              documentation: [
                 Some assets were transferred out. [asset, from, to, amount].,
                 TechAccountId is only pure TechAccountId.
              ]
            },
            {
              name: InputTransferred,
              args: [
                TechAssetId,
                AccountId,
                TechAccountId,
                Balance
              ],
              documentation: [
                 Some assets were transferred in. [asset, from, to, amount].,
                 TechAccountId is only pure TechAccountId.
              ]
            },
            {
              name: SwapSuccess,
              args: [
                AccountId
              ],
              documentation: [
                 Swap operaction is finalised [initiator, finaliser].,
                 TechAccountId is only pure TechAccountId.
              ]
            }
          ],
          constants: [],
          errors: [
            {
              name: StorageOverflow,
              documentation: [
                 Errors should have helpful documentation associated with them.
              ]
            },
            {
              name: InsufficientBalance,
              documentation: [
                 Balance too low to send value.
              ]
            },
            {
              name: AlreadyExist,
              documentation: [
                 Swap already exists.
              ]
            },
            {
              name: InvalidProof,
              documentation: [
                 Swap proof is invalid.
              ]
            },
            {
              name: SourceMismatch,
              documentation: [
                 Source does not match.
              ]
            },
            {
              name: AlreadyClaimed,
              documentation: [
                 Swap has already been claimed.
              ]
            },
            {
              name: ClaimActionMismatch,
              documentation: [
                 Claim action mismatch.
              ]
            },
            {
              name: DurationNotPassed,
              documentation: [
                 Duration has not yet passed for the swap to be cancelled.
              ]
            },
            {
              name: OnlyRegularAsset,
              documentation: [
                 If argument must be technical, and only regular values inside it is allowed
              ]
            },
            {
              name: OnlyRegularAccount,
              documentation: [
                 If argument must be technical, and only regular values inside it is allowed
              ]
            },
            {
              name: OnlyRegularBalance,
              documentation: [
                 If argument must be technical, and only regular values inside it is allowed
              ]
            },
            {
              name: OnlyPureTechnicalAccount,
              documentation: [
                 If argument must be technical, and only regular values inside it is allowed
              ]
            },
            {
              name: Overflow,
              documentation: [
                 Got an overflow after adding.
              ]
            },
            {
              name: TechAccountIdMustBePure,
              documentation: [
                 If argument must be technical, and only pure technical value is allowed
              ]
            },
            {
              name: UnableToGetReprFromTechAccountId,
              documentation: [
                 It is not posible to extract code from `AccountId32` as representation,
                 or find it in storage.
              ]
            },
            {
              name: RepresentativeMustBeSupported,
              documentation: [
                 Type must sport mapping from hash to special subset of `AccountId32`
              ]
            },
            {
              name: TechAccountIdIsNotRegistered,
              documentation: [
                 It is not posible to find record in storage map about `AccountId32` representation for,
                 technical account.
              ]
            },
            {
              name: NotImplemented,
              documentation: [
                 This function or ablility is still not implemented.
              ]
            },
            {
              name: DecodeAccountIdFailed,
              documentation: [
                 Failed to decode `AccountId` from a hash.
              ]
            },
            {
              name: AssociatedAccountIdNotFound,
              documentation: [
                 Associated `AccountId` not found with a given `TechnicalAccountId`.
              ]
            }
          ]
        },
        {
          name: LiquidityProxy,
          storage: null,
          calls: [
            {
              name: swap_exact_input,
              args: [
                {
                  name: dex_id,
                  type: DEXId
                },
                {
                  name: input_asset_id,
                  type: AssetId
                },
                {
                  name: output_asset_id,
                  type: AssetId
                },
                {
                  name: amount,
                  type: Fixed
                },
                {
                  name: min_received,
                  type: Option<Fixed>
                },
                {
                  name: included_sources,
                  type: Option<Vec<LiquiditySourceType>>
                },
                {
                  name: excluded_sources,
                  type: Option<Vec<LiquiditySourceType>>
                }
              ],
              documentation: [
                 Swaps an exact amount of the input asset with as much of output asset as possible.,
                ,
                 - `origin`: the account on whose behalf the transaction is being executed,,
                 - `dex_id`: DEX ID for which liquidity sources aggregation is being done,,
                 - `input_asset_id`: ID of the asset being sold,,
                 - `output_asset_id`: ID of the asset being bought,,
                 - `amount`: the exact amount to be sold (in input_assed_id units),,
                 - `min_received`: Optional. If the amount of output asset slips below this value the trade is reverted,,
                 - `included_sources`: Optional. A list of liquidity sources to include into aggregation pool,,
                 - `excluded_sources`: Optional. A list of liquidity sources to exclude from aggregation pool; ignored if `included_sources` is specified.,
                ,
                 TODO: add information about weight
              ]
            },
            {
              name: swap_exact_output,
              args: [
                {
                  name: dex_id,
                  type: DEXId
                },
                {
                  name: input_asset_id,
                  type: AssetId
                },
                {
                  name: output_asset_id,
                  type: AssetId
                },
                {
                  name: amount,
                  type: Fixed
                },
                {
                  name: max_spent,
                  type: Option<Fixed>
                },
                {
                  name: included_sources,
                  type: Option<Vec<LiquiditySourceType>>
                },
                {
                  name: excluded_sources,
                  type: Option<Vec<LiquiditySourceType>>
                }
              ],
              documentation: [
                 Swaps as little as possible of the input asset to get a fixed amount of the output asset.,
                ,
                 - `origin`: the account on whose behalf the transaction is being executed,,
                 - `dex_id`: DEX ID for which liquidity sources aggregation is being done,,
                 - `input_asset_id`: ID of the asset being sold,,
                 - `output_asset_id`: ID of the asset being bought,,
                 - `amount`: the exact amount to be bought (in output_asset_id units),,
                 - `max_spent`: Optional. If the amount of input asset slips above this value the trade is reverted,,
                 - `included_sources`: Optional. A list of liquidity sources to include into aggregation pool,,
                 - `excluded_sources`: Optional. A list of liquidity sources to exclude from aggregation pool; ignored if `included_sources` is specified.,
                ,
                 TODO: add information about weight
              ]
            }
          ],
          events: [
            {
              name: Exchange,
              args: [
                AccountId,
                DEXId,
                AssetId,
                AssetId,
                Fixed,
                Fixed
              ],
              documentation: [
                 Exchange of tokens has been performed,
                 [Caller Account, DEX Id, Input Asset Id, Output Asset Id, Input Amount, Output Amount]
              ]
            }
          ],
          constants: [],
          errors: [
            {
              name: UnavailableExchangePath,
              documentation: [
                 No route exists in a given DEX for given parameters to carry out the swap
              ]
            },
            {
              name: MaxFeeExceeded,
              documentation: [
                 Max fee exceeded
              ]
            },
            {
              name: InvalidFeeValue,
              documentation: [
                 Fee value outside of the basis points range [0..10000]
              ]
            },
            {
              name: InsufficientLiquidity,
              documentation: [
                 None of the sources has enough reserves to execute a trade
              ]
            }
          ]
        },
        {
          name: MockLiquiditySource,
          storage: {
            prefix: Instance1MockLiquiditySourceModule,
            items: [
              {
                name: Reserves,
                modifier: Default,
                type: {
                  DoubleMap: {
                    hasher: Blake2_128Concat,
                    key1: DEXId,
                    key2: AssetId,
                    value: (Fixed,Fixed),
                    key2Hasher: Blake2_128Concat
                  }
                },
                fallback: 0x0000000000000000000000000000000000000000000000000000000000000000,
                documentation: []
              },
              {
                name: ReservesAcc,
                modifier: Default,
                type: {
                  Plain: TechAccountId
                },
                fallback: 0x020000000000000000000000000000000000000000000000000000000000000000,
                documentation: []
              }
            ]
          },
          calls: [
            {
              name: test_access,
              args: [
                {
                  name: dex_id,
                  type: DEXId
                },
                {
                  name: target_id,
                  type: AssetId
                }
              ],
              documentation: []
            },
            {
              name: set_reserve,
              args: [
                {
                  name: dex_id,
                  type: DEXId
                },
                {
                  name: target_id,
                  type: AssetId
                },
                {
                  name: base_reserve,
                  type: Fixed
                },
                {
                  name: target_reserve,
                  type: Fixed
                }
              ],
              documentation: []
            }
          ],
          events: [
            {
              name: ReservesUpdated,
              args: [
                AccountId,
                AssetId,
                Fixed,
                AssetId,
                Fixed
              ],
              documentation: []
            }
          ],
          constants: [],
          errors: [
            {
              name: PairDoesNotExist,
              documentation: []
            },
            {
              name: InsufficientInputAmount,
              documentation: []
            },
            {
              name: InsufficientOutputAmount,
              documentation: []
            },
            {
              name: InsufficientLiquidity,
              documentation: []
            }
          ]
        },
        {
          name: MockLiquiditySource2,
          storage: {
            prefix: Instance2MockLiquiditySourceModule,
            items: [
              {
                name: Reserves,
                modifier: Default,
                type: {
                  DoubleMap: {
                    hasher: Blake2_128Concat,
                    key1: DEXId,
                    key2: AssetId,
                    value: (Fixed,Fixed),
                    key2Hasher: Blake2_128Concat
                  }
                },
                fallback: 0x0000000000000000000000000000000000000000000000000000000000000000,
                documentation: []
              },
              {
                name: ReservesAcc,
                modifier: Default,
                type: {
                  Plain: TechAccountId
                },
                fallback: 0x020000000000000000000000000000000000000000000000000000000000000000,
                documentation: []
              }
            ]
          },
          calls: [
            {
              name: test_access,
              args: [
                {
                  name: dex_id,
                  type: DEXId
                },
                {
                  name: target_id,
                  type: AssetId
                }
              ],
              documentation: []
            },
            {
              name: set_reserve,
              args: [
                {
                  name: dex_id,
                  type: DEXId
                },
                {
                  name: target_id,
                  type: AssetId
                },
                {
                  name: base_reserve,
                  type: Fixed
                },
                {
                  name: target_reserve,
                  type: Fixed
                }
              ],
              documentation: []
            }
          ],
          events: [
            {
              name: ReservesUpdated,
              args: [
                AccountId,
                AssetId,
                Fixed,
                AssetId,
                Fixed
              ],
              documentation: []
            }
          ],
          constants: [],
          errors: [
            {
              name: PairDoesNotExist,
              documentation: []
            },
            {
              name: InsufficientInputAmount,
              documentation: []
            },
            {
              name: InsufficientOutputAmount,
              documentation: []
            },
            {
              name: InsufficientLiquidity,
              documentation: []
            }
          ]
        },
        {
          name: MockLiquiditySource3,
          storage: {
            prefix: Instance3MockLiquiditySourceModule,
            items: [
              {
                name: Reserves,
                modifier: Default,
                type: {
                  DoubleMap: {
                    hasher: Blake2_128Concat,
                    key1: DEXId,
                    key2: AssetId,
                    value: (Fixed,Fixed),
                    key2Hasher: Blake2_128Concat
                  }
                },
                fallback: 0x0000000000000000000000000000000000000000000000000000000000000000,
                documentation: []
              },
              {
                name: ReservesAcc,
                modifier: Default,
                type: {
                  Plain: TechAccountId
                },
                fallback: 0x020000000000000000000000000000000000000000000000000000000000000000,
                documentation: []
              }
            ]
          },
          calls: [
            {
              name: test_access,
              args: [
                {
                  name: dex_id,
                  type: DEXId
                },
                {
                  name: target_id,
                  type: AssetId
                }
              ],
              documentation: []
            },
            {
              name: set_reserve,
              args: [
                {
                  name: dex_id,
                  type: DEXId
                },
                {
                  name: target_id,
                  type: AssetId
                },
                {
                  name: base_reserve,
                  type: Fixed
                },
                {
                  name: target_reserve,
                  type: Fixed
                }
              ],
              documentation: []
            }
          ],
          events: [
            {
              name: ReservesUpdated,
              args: [
                AccountId,
                AssetId,
                Fixed,
                AssetId,
                Fixed
              ],
              documentation: []
            }
          ],
          constants: [],
          errors: [
            {
              name: PairDoesNotExist,
              documentation: []
            },
            {
              name: InsufficientInputAmount,
              documentation: []
            },
            {
              name: InsufficientOutputAmount,
              documentation: []
            },
            {
              name: InsufficientLiquidity,
              documentation: []
            }
          ]
        },
        {
          name: MockLiquiditySource4,
          storage: {
            prefix: Instance4MockLiquiditySourceModule,
            items: [
              {
                name: Reserves,
                modifier: Default,
                type: {
                  DoubleMap: {
                    hasher: Blake2_128Concat,
                    key1: DEXId,
                    key2: AssetId,
                    value: (Fixed,Fixed),
                    key2Hasher: Blake2_128Concat
                  }
                },
                fallback: 0x0000000000000000000000000000000000000000000000000000000000000000,
                documentation: []
              },
              {
                name: ReservesAcc,
                modifier: Default,
                type: {
                  Plain: TechAccountId
                },
                fallback: 0x020000000000000000000000000000000000000000000000000000000000000000,
                documentation: []
              }
            ]
          },
          calls: [
            {
              name: test_access,
              args: [
                {
                  name: dex_id,
                  type: DEXId
                },
                {
                  name: target_id,
                  type: AssetId
                }
              ],
              documentation: []
            },
            {
              name: set_reserve,
              args: [
                {
                  name: dex_id,
                  type: DEXId
                },
                {
                  name: target_id,
                  type: AssetId
                },
                {
                  name: base_reserve,
                  type: Fixed
                },
                {
                  name: target_reserve,
                  type: Fixed
                }
              ],
              documentation: []
            }
          ],
          events: [
            {
              name: ReservesUpdated,
              args: [
                AccountId,
                AssetId,
                Fixed,
                AssetId,
                Fixed
              ],
              documentation: []
            }
          ],
          constants: [],
          errors: [
            {
              name: PairDoesNotExist,
              documentation: []
            },
            {
              name: InsufficientInputAmount,
              documentation: []
            },
            {
              name: InsufficientOutputAmount,
              documentation: []
            },
            {
              name: InsufficientLiquidity,
              documentation: []
            }
          ]
        },
        {
          name: DEXAPI,
          storage: null,
          calls: [],
          events: [
            {
              name: SomethingHappened,
              args: [
                AccountId
              ],
              documentation: []
            }
          ],
          constants: [],
          errors: [
            {
              name: DEXIdDoesNotExist,
              documentation: []
            }
          ]
        }
      ],
      extrinsic: {
        version: 4,
        signedExtensions: [
          CheckTxVersion,
          CheckGenesis,
          CheckMortality,
          CheckNonce,
          CheckWeight,
          ChargeTransactionPayment
        ]
      }
    }
  }
}